# USACO刷题笔记
## [USACO24DEC] Roundabount Rounding B
### 题意概括：四舍五入 vs 链式舍入
### 题解：打表找规律
1. 暴力枚举

  $T(T<=10^5)$ 个用例，每个用例输入数字 $N <= 10^9$。
  暴力枚举复杂度是 $O(T*N)$ 必超时

2. 通过打表找规律
```
45 46 47 48 49
445 446 447 448 449 450 451…… 497 498 499
4445 4446 4447 4448 4449 4450 4451 …… 4997 4998 4999
……
```
【规律】如果前面全是4，后面紧跟一个5-9，之后是任何数都行，那么两种进位的结果不同
这是个充要条件。

总之 [44444…5, 49999…9] 都可以.

不难得出如下的规律。由于数据范围不大，对每个区间的左端和右端可以打表来进行处理。
```
int fir[10]=
{0,45,445,4445,44445,444445,4444445,44444445,444444445,4444444445};
int sec[10]=
{0,50,500,5000,50000,500000,5000000,50000000,500000000,5000000000};
//这里用的是左闭右开区间
```

那么接下来只需对 N 进行搜索即可，看其是否在当前区间内。如果小于区间左端就代表搜索完毕，输出答案。如果大于区间右端就加上这个区间的数的个数，并搜索下一个区间。如果在当前区间内，就加上当前区间内小于等于 N 的数的个数并输出。

## [USACO24DEC] Farmer John's Cheese Block B
### 题意概括：立方体形状的奶酪，挖去一些小块后，会不会出现贯穿的空洞

### 题解：利用map优化查询
map不一定要用STL的map/unordered_map, 数组也可以实现map

如果map <key, value> 的key是范围比较小的整数，那么就可以用数组表示map
否则如果key是字符串、比较大的整数或其他复杂类型，那么就用STL

  1. 暴力

直接的方法是用三维数组表示立方体，然后记录每个块是否还在。

很显然当 N≤100 时，可以开数组标记是否已经被挖掉。判断那些位置可以插入木棒时，
$O(N^2)$ 枚举$(x,y)$，$(x,z)$ 和 $(y,z)$，然后 $O(N)$ 判断是否可以插入。复杂度 
$O(N^3 * Q)$。

  2. 对暴力进行优化
  
  因为是在不停地抠奶酪，所以不难发现答案是单调不减的。

  发现对于每一组相同的 $(x,y)$ 或 $(x,z)$ 或 $(y,z)$ 坐标，当且仅当这一条被覆盖了 N 次后，才会对答案产生 
+1 的贡献。开三个 map(二维数组表示即可) 记录一下，每次更新的时候判断一下是否满足条件即可。

## [USACO24DEC] It's Mooin' Time B
###  
  开始写程序之前，最好能够用文字把算法步骤写个提纲，这样程序写起来比较快，不容易出错。
  除非算法太简单，可以直接开始写。
  // 1. ....
  // 2. ....
  // 3. ....
  
  如果设计的算法太复杂，需要考虑很多细节，那么先想想是否有更好的方法。
  例如本题，可以枚举所有的位置，也可以枚举所有的moo，多试着换种思路想想。
  
  暴力枚举经常有多种枚举方案，选择简单的。
  
    一种哞叫一般地定义为子串ci cj cj， 其中某字符 ci 之后紧跟着 2 个某字符 
cj ，且 ci≠cj 。根据 Farmer John 的说法，Bessie 哞叫了很多，所以如果某种哞叫
在竞赛中出现了至少 F（1≤F≤N）次，那可能就是 Bessie 发出的

  这个题目可能有多种思路：
  1. 一种是对于每一个位置，判断能否和后两个位置组成一种声音moo，和更改一个字符后组成的声音，
  然后统计所有声音出现的次数。 moo, mox, mxo, xoo
    这种写法需要考虑的细节比较多。
  2. 第二种是对于每一种声音（将其命名为 moo ），统计出现次数。
